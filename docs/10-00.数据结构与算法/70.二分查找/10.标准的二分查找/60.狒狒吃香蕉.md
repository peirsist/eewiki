---
title: 狒狒吃香蕉
date: 2022-05-06 11:44:11
permalink: /pages/5288d3/
---
## 📃 题目描述

题目链接：

- [剑指 Offer II 073. 狒狒吃香蕉 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/nZZqjQ/)
- [875. 爱吃香蕉的珂珂 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/koko-eating-bananas/)

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20220506114453.png)

## 🔔 解题思路

**虽然还不知道狒狒1小时至少要吃几根香蕉才能在门卫回来之前吃完所有的香蕉，但知道它吃香蕉的速度的范围**。显然，它每小时至少要吃1根香蕉。由于它1小时内只吃一堆香蕉，因此它每小时吃香蕉数目的上限是最大一堆香蕉的数目，记为max根。

也就是说，狒狒吃香蕉的速度应该在最小值1根和最大值max根的范围内。在1～max根取中间值mid根，求出按照每小时吃mid根香蕉的速度吃完所有香蕉的时间

- 如果需要的时间多于H小时，则意味着它应该吃得更快一些，因此狒狒吃香蕉的速度应该在mid+1根到max根这个范围内

- 如果需要的时间少于或等于H小时，那么**先判断 mid 根是不是最慢的速度**，判断的办法是计算如果按照每小时吃 mid-1 根香蕉的速度需要多久吃完

  - ⭐ **如果按照每小时吃 mid-1 根香蕉的速度需要的时间也小于或等于 H 小时，意味着每小时 mid 根香蕉不是能在H小时吃完所有香蕉的最慢的速度，因此狒狒吃香蕉的速度应该在 1 根到 mid-1 根之间**

    > 注意这里计算出来的每小时吃 mid-1 根香蕉的速度需要的时间，不是和 hours 比较，而是和 H 比较，因为目的是求规定时间内吃完的最小速度，而不是耗费的时间越少越好。只要能够在规定的时间 H 内能吃完，速度越慢越好

  - 如果按照每小时 mid-1 根香蕉的速度吃完所有香蕉需要的时间大于H小时，这意味着mid根就是能在H小时内吃完所有香蕉的最慢速度。整个过程其实就是在 1 根到 max 根之间做二分查找。

举个例子，求狒狒用8小时吃完4堆数目分别为[3，6，7，11]的最慢速度为例分析二分查找的过程。

显然，狒狒每小时至少吃1根香蕉，每小时最多吃11根香蕉，于是先计算以中间值每小时吃6根香蕉的速度吃完所有香蕉所需要的时间。

- 如果每小时吃6根香蕉，吃完4堆香蕉分别需要1小时、1小时、2小时、2小时，总共需要6小时，少于8小时，接着判断每小时吃6根香蕉是不是能在8小时吃完的最慢速度：
  - 判断的办法是让狒狒尝试慢一点的速度，每小时吃5根香蕉。如果狒狒每小时吃5根香蕉，它吃完4堆香蕉分别需要1小时、2小时、2小时、3小时，总共需要8小时。因此，每小时吃6根香蕉不是最慢的速度。接下来可以在1根到5根的范围内查找。
- 1根到5根的中间值是3根。如果狒狒每小时吃3根香蕉，它吃完4堆香蕉分别需要1小时、2小时、3小时、4小时，吃完所有香蕉总共需要10小时。因此，它需要吃得快一些。接下来在4根到5根的范围内查找。
- 接着尝试4根到5根的中间值4根。如果狒狒每小时吃4根香蕉，那么它吃完4堆香蕉分别需要1小时、2小时、2小时、3小时，吃完所有香蕉需要8小时，等于8小时，接着判断每小时吃4根香蕉是不是能在8小时吃完所有香蕉的最慢速度：
  - 如果狒狒每小时只吃3根香蕉，那么它需要10小时才能吃完所有香蕉，因此每小时吃4根香蕉的确是它能在8小时吃完所有香蕉的最慢速度。


```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max = Integer.MIN_VALUE;
        for (int pile : piles) {
            max = Math.max(pile, max);
        }

        int left = 1;
        int right = max;
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            // 以速度 mid 根/小时吃香蕉，需要的时间
            int hours = getHours(piles, mid);
            // 如果 hours <= h，判断 mid 是不是已经是最小速度
            if (hours <= h) {
                if (mid == 1 || getHours(piles, mid - 1) > h) {
                    // 注意这里 getHours(piles, mid - 1) 不是和 hours 比较，而是和 h 比较
                    // 目的是求规定时间内吃完的最小速度，而不是耗费的时间越少越好
                    return mid;
                }

                // 如果不是最小速度，那么减小速度，收缩右边界
                right = mid - 1;
            }
            // 如果 hours > h，那么需要增大速度
            else {
                left = mid + 1;
            }
        }

        return -1;
    }

    // 以速度 mid 根/小时吃香蕉堆 piles，需要的时间
    private int getHours(int[] piles, int speed) {
        int hours = 0;
        for (int pile : piles) {
            if (speed >= pile) {
                hours += 1;
            }
            else {
                hours += (pile % speed == 0) ? (pile / speed) : (pile / speed + 1);
            }
        }

        return hours;
    }
}
```

## 💥 复杂度分析

- 空间复杂度：O(1)
- 时间复杂度：二分查找时间复杂度 O(LogN)，getHours 时间复杂度 O(N)，因此总时间复杂度 O(NlogN)


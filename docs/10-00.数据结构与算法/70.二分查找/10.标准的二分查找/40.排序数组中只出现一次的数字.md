---
title: 排序数组中只出现一次的数字
date: 2022-05-05 11:36:03
permalink: /pages/1e0f67/
---
## 📃 题目描述

题目链接：

- [剑指 Offer II 070. 排序数组中只出现一次的数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/skFtm2/)
- [540. 有序数组中的单一元素 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

## 🔔 解题思路

如果这题数组不是有序的，那么就和这题 [136. 只出现一次的数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/single-number/) 一样，直接异或做就行了

不过这题数组有序，可以用二分查找来做进一步的优化

在一个排序数组中，如果所有数字都出现了两次，那么将数组中的数字每两个分成一组，每组的两个数字都是相等的。但如果在数组中添加一个只出现一次的数字，那么这个规律就会被打破。

例如，在数组[1，1，2，2，3，4，4，5，5]中，如果将两个数字分成一组，可以分成（1，1）、（2，2）、（3，4）和（4，5），以及最后还剩下的数字5。在这几组数字中，前两组的数字分别相同，但后面两组的数字就不相同

数组中的数字每两个分成一组，最初的若干组的两个数字都是相同的。但遇到了只出现一次的数字之后，情况发生变化。这个只出现一次的数字和后面的数字结合成一组，导致后面所有出现两次的数字都被分到两个不同的组，即后面所有组的两个数字都不相同。由此可见，**只出现一次的数字正好是第1个两个数字不相等的分组的第 1 个数字**

接着考虑如何用二分查找的思路来解决这个问题。

将数组中的数字每两个分为一组。先找出位于中间的一组，确定这一组的两个数字是否相同：

- 如果两个数字相同，那么那个只出现一次的数字一定在它的后面，因此接着查找它的后半部分。
- 如果两个数字不相同，那么接着检查这一组是不是第 1 组两个数字不相同的分组。
  - 如果是第 1 组，那么这一组的第1个数字就是只出现一次的数字。
  - 如果不是第 1 组，那么第 1 组一定在它的前面，因此接着查找它的前半部分

**最后考虑一个特例，如果直到最后都没有找到两个数字不同的分组，那是因为只出现一次的数字在数组的尾部**。

如果把这个数组的每两个数字分成一组，那么每个分组中的两个数字都相同。例如，在数组[1，1，2，2，3]中，可以将它分成（1，1）和（2，2），以及最后还剩下的一个数字3。此时数组的最后一个数字3就是只出现一次的数字。


```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        // [left, right] 表示区间下标 
        int left = 0;
        int right = nums.length / 2;
        
        while (left <= right) {
            // 中间区间
            int mid = left + ((right - left) >> 1);
            // 中间区间的第一个元素下标
            int i = mid * 2;

            // 如果不是最后一个区间，并且这个中间区间中两个数不相等，那么接着检查这一组是不是第 1 组两个数字不相同的分组
            if (i < nums.length - 1 && nums[i] != nums[i + 1]) {
                // 如果前面一个区间中两个数都相等，说明当前这个区间就是第 1 个两个数字不相同的区间
                if (mid == 0 || nums[i - 1] == nums[i - 2]) {
                    return nums[i];
                }

                // 如果前面一个区间中两个数不相等，收缩右边界，查找第 1 个两个数字不相同的区间
                right = mid - 1;
            }
            // 如果两个数字相同，那么那个只出现一次的数字一定在它的后面，因此接着查找它的后半部分，收缩左边界
            else {
                left = mid + 1;
            }
        }
		
        // 只出现一次的数可能出现在最后
        return nums[nums.length - 1];
    }
}
```

细节还是挺多的，注意看下面框起来的地方：

![](https://cs-wiki.oss-cn-shanghai.aliyuncs.com/img/20220505114425.png)

## 💥 复杂度分析

- 空间复杂度：
- 时间复杂度：

